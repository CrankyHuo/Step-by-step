    既然浏览器是和服务器交互，将数据和资源下载到本底，那么就必然会存在缓存，缓存就是让你不要每次都去访问服务器，你自己觉得慢，服务器也觉得你烦，但是有时候必须每次都要获取新的：例如天气预报···
  
  经过我学习整理了一下，常见的几种控制浏览器缓存的方法；
  > + `Expires`：服务器将会指明具体的过期日期，如果时间还没到规定的日期，如果再次发起相同的请求，并且本地缓存还在，浏览器就会直接调用本地缓存，但是恰好`Expires`只能够使用HTTP时间格式的日期时间，特就是GTM(格林威治)，中国所在的是GMT+8，所以在HTTP1.1里，开始使用了Cache-Control：max-age = 秒，如果说两者同时存在，则被`Cache-Control`的`max-age`覆盖
> ​ ![0_1462884787690_Expires_副本.png](http://7xpvnv.com2.z0.glb.qiniucdn.com/3cd5cedd-37a1-41ea-8988-64c2cb138312.png) 
> + `Cache-control`：max-age=[秒]；HTTP1.1协议新增的响应头信息，`max-age`类似过期时间，这个是基于请求时间的相对时间，而不是绝对的过期时间，s-maxage=[秒]也是类似前者，除了他应用于共享缓存(如代理服务器)；  
>![0_1462884800751_cache-control_副本.png](http://7xpvnv.com2.z0.glb.qiniucdn.com/8f9f2a9f-d5ea-495f-ab39-64daf20bfb51.png) 
> + `Last-Modified/If-Modified-Since`：但是有些数据是变化的，例如一个视屏网站首页经常更新，当然也有的老站年久失修，但是Web服务器是不变的，服务器是知道你请求的资源最后的修改日期并且HTTP为服务器提供了一种将最近修改数据连同你的请求一起发送的方法;
> ​    如果你第二次 (或第三次，或第四次) 请求相同的数据，你可以告诉服务器你上一次获得的最后修改日期：在你的请求中发送一个 If-Modified-Since 头信息，它包含了上一次从服务器连同数据所获得的日期。如果数据从那时起没有改变，服务器将返回一个特殊的 HTTP 状态代码 304，这意味着 “从上一次请求后这个数据没有改变”。这一点有何进步呢？当服务器发送状态编码 304 时，不再重新发送数据。您仅仅获得了这个状态代码。所以当数据没有更新时，你不需要一次又一次地下载相同的数据；服务器假定你有本地的缓存数据。
> ![0_1462884836917_max-age.PNG](http://7xpvnv.com2.z0.glb.qiniucdn.com/25365f78-fa0d-449d-8f9b-1bad752ceb0f.PNG) 
> + `ETag/If-None-Match`:`ETag` 是实现与最近修改数据检查同样的功能的另一种方法：没有变化时不重新下载数据。其工作方式是：服务器发送你所请求的数据的同时，发送某种数据的 hash (在 ETag 头信息中给出)。hash 的确定完全取决于服务器。当第二次请求相同的数据时，你需要在 If-None-Match: 头信息中包含 ETag hash，如果数据没有改变，服务器将返回 304 状态代码。与最近修改数据检查相同，服务器仅仅 发送 304 状态代码；第二次将不为你发送相同的数据。在第二次请求时，通过包含 ETag hash，你告诉服务器：如果 hash 仍旧匹配就没有必要重新发送相同的数据，因为你还有上一次访问过的数据。
> + 这几个http头可以作为meta标签发送到客户端，但是写在HTTP头中的设置优先级更高一些；而且写在HTML 的META标签里面，但是遇到代理服务器这种不解析HTML内容的家伙，就不支持了；
> + 总结：
> 1. Expires/Cache-Control Header是控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只是Cache-Control比Expires可以控制的多一些， 而且Cache-Control会重写Expires的规则。
> 2. Last-Modified/If-Modified-Since和ETag/If-None-Match是浏览器发送请求到服务器后判断文件是否 已经修改过，如果没有修改过就只发送一个304回给浏览器，告诉浏览器直接从自己本地的缓存取数据；如果修改过那就整个数据重新发给浏览器。